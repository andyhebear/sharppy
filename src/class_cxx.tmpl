## $Id: class_cxx.tmpl,v 1.35 2003-11-18 17:50:06 patrick Exp $

#from TemplateHelpers import makeCPlusPlusTypedef, getDeclName, getCallbackName, getBridgeName, getHolderName, getSelfType
#from visitors import CPlusPlusVisitor, CPlusPlusReturnVisitor, CPlusPlusParamVisitor

#def fillMethodWrapperBody($methodDecl, $methodCall, $classObj = None, $classVisitor = None)
#set $param_visitor  = CPlusPlusParamVisitor()
#set $params = ['%s %s' % (getDeclUsage(x[0], $param_visitor), x[1]) for x in $methodDecl.parameters]
#if not $methodDecl.static
#silent $params[0:0] = ["%s self_" % $getSelfType($classObj, $classVisitor)]
#if $classObj.info.only_smart_ptr
#set $methodCall = $methodCall % 'mPtr->'
#else
#set $methodCall = $methodCall % ''
#end if
#end if
#set $p = ', '.join($params)
#set $method_visitor = CPlusPlusVisitor()
#set $return_visitor = CPlusPlusReturnVisitor()
#silent $methodDecl.result.accept($return_visitor)
#silent $methodDecl.accept($method_visitor)
#if $methodDecl.virtual
#set $method_type = 'virtual'
#elif $methodDecl.static
#set $method_type = 'static'
#else
#set $method_type = 'non-virtual'
#end if
   // Wrapper for $method_type method ${method_visitor.getRawName()}()
   SHARPPY_API $return_visitor.getUsage() ${method_visitor.getGenericName()}($p)
   {
## Pre-call parameter marshaling.
#set $all_args = []
#for $param in $methodDecl.parameters
#silent $param_visitor.setParamName($param[1])
#silent $param[0].accept($param_visitor)
#if $param_visitor.mustMarshal()
      $param_visitor.getPreCallMarshal(); // Pre-call marshaling for $param[1]
#silent $all_args.append($param_visitor.getMarshalParamName())
#else
#silent $all_args.append($param[1])
#end if
#end for
#set $arg_list = ', '.join($all_args)
#set $returns = $return_visitor.getRawName() != 'void'
#set $method_call = $methodCall + '(' + $arg_list + ')'
## Return value marshaling.
#if $returns
$return_visitor.getMethodCall($method_call, '      ')
#else
      $method_call;
#end if
## Post-call parameter marshaling.
#for $param in $methodDecl.parameters
#silent $param[0].accept($param_visitor)
#if $param_visitor.mustMarshal()
      $param_visitor.getPostCallMarshal(); // Post-call marshaling for $param[1]
#end if
#end for
#if $returns
      return $return_visitor.getResultVarName();
#end if
   }
#end def

#def exportClass($classObj)
#set $class_visitor = CPlusPlusVisitor()
#set $generic_visitor = CPlusPlusVisitor()
#set $param_visitor = CPlusPlusParamVisitor()
#silent $classObj.class_.accept($class_visitor)
#set $class_name = $class_visitor.getRawName()
\#include "sharppy.h"
#for $i in $classObj.includes
\#include <$i>
#end for

#if $classObj.hasVirtualMethods()
#set $class_name = getBridgeName($class_visitor)
#set $class_id   = $class_name
## Get the list of base classes (there will be at least one) for the bridge.
#set $base_list = ['public ' + $class_visitor.getRawName()]
#for $x in $classObj.bridge_bases
#silent $x.accept($generic_visitor)
#silent $base_list.append('public %s' % getBridgeName($generic_visitor))
#end for
class $class_name : #echo ', '.join($base_list)
{
public:
#for $c in $classObj.constructors
#set $p = ', '.join(['%s %s' % (getDeclName(x[0], $generic_visitor), x[1]) for x in $c.parameters])
#set $arg_list = ', '.join([x[1] for x in $c.parameters])
   ${class_name}($p)
      : ${class_visitor.getRawName()}($arg_list)
   {;}

#end for
   virtual ~${class_name}()
   {;}

#set $return_visitor = CPlusPlusReturnVisitor()
#for $m in $classObj.virtual_methods
#if not $m.abstract
#set $callback_name = getCallbackName($m)
   $makeCPlusPlusTypedef($m);
   ${callback_name}_t $callback_name;

#silent $m.result.accept($return_visitor)
#set $p = ', '.join(['%s %s' % (getDeclName(x[0], $generic_visitor), x[1]) for x in $m.parameters])
#set $arg_list = ', '.join([x[1] for x in $m.parameters])
   virtual $return_visitor.getRawName() ${m.name[0]}($p)
   {
#set $returns = $return_visitor.getRawName() != 'void'
#set $call = '%s(%s)' % ($getCallbackName($m), $arg_list)
#if $return_visitor.mustMarshal()
#set $call = '*(%s);' % $call
#end if
      #if $returns then 'return ' else ''#$call;
   }

#end if
#end for
}; // class $class_name
#else
#set $class_name = $class_visitor.getRawName()
#set $class_id   = $class_visitor.getGenericName()
#end if

#if $classObj.smart_ptr
struct $getHolderName($class_visitor)
{
#set $smart_ptr_decl = $classObj.info.smart_ptr_decl % $class_visitor.getRawName()
   $smart_ptr_decl mPtr;
};
#end if

extern "C"
{
#set $method_visitor = CPlusPlusVisitor()
## We have a class that only appears as a smart pointer.  We only have one
## constructor that copies the existing object.
#if $classObj.info.only_smart_ptr
#set $holder_name = $getHolderName($class_visitor)
   SHARPPY_API $holder_name* new_${holder_name}($smart_ptr_decl ptr)
   {
      $holder_name* h = new $holder_name;
      h->mPtr = ptr;
      return h;
   }
## We have a class that does not necessarily appear as a smart pointer.  The
## handling of this case is much more complicated.
#else
#for $c in $classObj.constructors
#silent $c.accept($method_visitor)
#set $cons_name = $method_visitor.getGenericName()
## Handle the copy constructor a little different since we know what the
## argument type will be.
#if $c.IsCopy()
   // Copy constructor wrapper.
   SHARPPY_API $class_visitor.getRawName()* ${cons_name}(const ${class_name}* p)
#else
## For non-copy constructors, build up the parameter list.
#set $param_list = ['%s %s' % (getDeclUsage(x[0], $param_visitor), x[1]) for x in $c.parameters]
#for $j in range(len($classObj.virtual_methods))
#set $q = '%s::%s_t cb%s' % ($class_name, getCallbackName($classObj.virtual_methods[$j]), $j)
#silent $param_list.append($q)
#end for
#set $p = ', '.join($param_list)
   // Constructor wrapper.
   SHARPPY_API $class_visitor.getRawName()* ${cons_name}($p)
#end if
   {
## Copy constructor body.
#if $c.IsCopy()
      $class_name* obj = new ${class_name}(*p);
#for $m in $classObj.virtual_methods
#set $callback_name = getCallbackName($m)
      obj->$callback_name = p->$callback_name;
#end for
## Normal constructor body.
#else
## Pre-call parameter marshaling.
#set $all_args = []
#for $param in $c.parameters
#silent $param_visitor.setParamName($param[1])
#silent $param[0].accept($param_visitor)
#if $param_visitor.mustMarshal()
      $param_visitor.getPreCallMarshal(); // Pre-call marshaling for $param[1]
#silent $all_args.append($param_visitor.getMarshalParamName())
#else
#silent $all_args.append($param[1])
#end if
#end for
#set $arg_list = ', '.join($all_args)
      $class_name* obj = new ${class_name}($arg_list);
#for $count in range(len($classObj.virtual_methods))
#set $callback_name = getCallbackName($classObj.virtual_methods[$count])
      obj->$callback_name = cb$count;
#end for
## Post-call parameter marshaling.
#for $param in $c.parameters
#silent $param[0].accept($param_visitor)
#if $param_visitor.mustMarshal()
      $param_visitor.getPostCallMarshal(); // Post-call marshaling for $param[1]
#end if
#end for
#end if
      return ($class_visitor.getRawName()*) obj;
   }

## End of constructor loop.
#end for
#end if
## Simple destructor wrapper.  All classes will have one.
## XXX: What about classes with non-public destructors?
   SHARPPY_API void delete_${class_id}($getSelfType($classObj, $class_visitor) self_)
   {
      delete self_;
   }

## ---------------------------- Non-virtual methods ---------------------------
#for $m in $classObj.non_virtual_methods
#set $method_call = 'self_->%s' + $m.name[0]
$fillMethodWrapperBody($m, $method_call, $classObj, $class_visitor)
#end for

## ------------------------------ Virtual methods -----------------------------
## XXX: Come up with a way to eliminate the use of a visitor here so that all
## of that is handled by fillMethodWrapperBody().
#set $method_visitor = CPlusPlusVisitor()
#for $m in $classObj.virtual_methods
#if not $m.abstract
#silent $m.accept($method_visitor)
#set $method_call = 'self_->%s' + $method_visitor.getRawName()
$fillMethodWrapperBody($m, $method_call, $classObj, $class_visitor)
#end if
#end for

## ------------------------------ Static methods ------------------------------
#for $m in $classObj.static_methods
#silent $m.accept($method_visitor)
$fillMethodWrapperBody($m, $method_visitor.getRawName())
#end for

## ---------------------------- Static data members ---------------------------
#set $data_visitor = CPlusPlusVisitor()
#set $data_type_visitor = CPlusPlusVisitor()
#for $m in $classObj.static_members
#silent $m.accept($data_visitor)
#silent $m.type.accept($data_type_visitor)
#set $set_name = $data_visitor.getGenericName() + '_set'
#set $get_name = $data_visitor.getGenericName() + '_get'
#if $m.type.must_marshal
#set $native_type = '%s*' % $data_type_visitor.getRawName()
#else
#set $native_type = $data_type_visitor.getRawName()
#end if
   // Wrapper for reading static data member $data_visitor.getRawName()
   SHARPPY_API $native_type ${get_name}()
   {
#if $m.type.must_marshal
## XXX: This probably isn't even close to correct ...
      return &$class_visitor.getRawName()::$m.name[0];
#else
      return $class_visitor.getRawName()::$m.name[0];
#end if
   }

#if not $m.type.const
   // Wrapper for modifying static data member $data_visitor.getRawName()
   SHARPPY_API void ${set_name}($native_type v)
   {
#if $m.type.must_marshal
## XXX: This probably isn't even close to correct ...
      $class_visitor.getRawName()::$m.name[0] = *v;
#else
      $class_visitor.getRawName()::$m.name[0] = v;
#end if
   }
#end if

#end for
} // extern "C" for $class_visitor.getRawName()

#set $nested_visitor = CPlusPlusVisitor()
#for $nc in $classObj.nested_classes
#silent $nc.class_.accept($nested_visitor)
// Nested class $nested_visitor.getRawName().
$exportClass($nc)
#end for
#end def

$exportClass($exp_class)
