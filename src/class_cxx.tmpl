## $Id: class_cxx.tmpl,v 1.59 2004-02-20 23:39:20 patrick Exp $
// Generated from \$Revision: 1.59 $ of \$RCSfile: class_cxx.tmpl,v $
#import TemplateHelpers
#import visitors

#def fillMethodWrapperBody($methodDecl, $methodCall, $classObj = None, $className = None)
#set $method_visitor = visitors.CPlusPlusFunctionWrapperVisitor()
#silent $method_visitor.setClassInfo($classObj, $className)
#silent $method_visitor.setCall($methodCall)
#silent $methodDecl.accept($method_visitor)
#set $params = ', '.join($method_visitor.getParamTypeList())
   // Wrapper for $method_visitor.getKind() method ${method_visitor.getRawName()}()
   SHARPPY_API $method_visitor.getReturnType() ${method_visitor.getGenericName()}($params)
   {
## Pre-call parameter marshaling.
#for $pre_marshal in $method_visitor.getPreCallMarshalList()
      $pre_marshal;
#end for
#for $method_call_line in $method_visitor.getCallLines()
      $method_call_line
#end for
## Post-call parameter marshaling.
#for $post_marshal in $method_visitor.getPostCallMarshalList()
      $post_marshal;
#end for
#if $method_visitor.returns()
      $method_visitor.getReturnStatement();
#end if
   }
#del $method_visitor
#end def

#def exportClass($classObj)
#set $class_visitor = visitors.CPlusPlusVisitor()
#set $generic_visitor = visitors.CPlusPlusVisitor()
#set $param_visitor = visitors.CPlusPlusParamVisitor()
#silent $classObj.class_.accept($class_visitor)
#set $class_id = $class_visitor.getGenericName()
#if $classObj.needsAdapter()
#set $class_name = TemplateHelpers.getAdapterName($class_visitor)
#else
#set $class_name = $class_visitor.getRawName()
#end if
#set $adapter_name = $class_name
#if $classObj.smart_ptr
struct $TemplateHelpers.getHolderName($class_visitor)
{
#if $classObj.info.smart_ptr_decl
#set $smart_ptr_decl = $classObj.info.smart_ptr_decl % $class_visitor.getRawName()
#else
#set $smart_ptr_decl = $class_visitor.getRawName()
#end if
   $smart_ptr_decl mPtr;
};

#end if
extern "C"
{
#set $method_visitor = visitors.CPlusPlusVisitor()
## We have a class that only appears as a smart pointer.  We have at least one
## constructor that copies the existing object.
#if $classObj.info.smart_ptr
#set $holder_name = $TemplateHelpers.getHolderName($class_visitor)
   SHARPPY_API $holder_name* new_${holder_name}($smart_ptr_decl ptr)
   {
      $holder_name* h = new $holder_name;
      h->mPtr = ptr;
      return h;
   }

#set $class_name = $holder_name
#end if
## We have a class that does not necessarily appear as a smart pointer.  The
## handling of this case is much more complicated.
#for $c in $classObj.constructors
## Skip the copy constructor for shared pointer types.  We have a special
## constructor defined above for that sort of thing.
#if $c.IsCopy() and $classObj.info.smart_ptr
#continue
#end if
#silent $c.accept($method_visitor)
#set $cons_name = $method_visitor.getGenericName()
## Handle the copy constructor a little different since we know what the
## argument type will be.
## For non-copy constructors, build up the parameter list.
#set $param_list = ['%s %s' % (TemplateHelpers.getDeclUsage(x[0], $param_visitor), x[1]) for x in $c.parameters]
#for $j in range(len($classObj.virtual_methods))
#set $q = '%s::%s_t cb%s' % ($adapter_name, TemplateHelpers.getCallbackName($classObj.virtual_methods[$j]), $j)
#silent $param_list.append($q)
#end for
#for $j in range(len($classObj.inherited_virtual_methods))
#set $q = '%s::%s_t cb%s' % ($adapter_name, TemplateHelpers.getCallbackName($classObj.inherited_virtual_methods[$j]), $j + len($classObj.virtual_methods))
#silent $param_list.append($q)
#end for
#set $p = ', '.join($param_list)
   // Constructor wrapper.
   SHARPPY_API $class_name* ${cons_name}($p)
   {
#if $classObj.info.smart_ptr
#set $obj_ref = 'obj->mPtr'
#else
#set $obj_ref = 'obj'
#end if
## Normal constructor body.
## Pre-call parameter marshaling.
#set $all_args = []
#for $param in $c.parameters
#silent $param_visitor.setParamName($param[1])
#silent $param[0].accept($param_visitor)
#if $param_visitor.mustMarshal()
      $param_visitor.getPreCallMarshal(); // Pre-call marshaling for $param[1]
#silent $all_args.append($param_visitor.getMarshalParamName())
#else
#silent $all_args.append($param[1])
#end if
#end for
#set $arg_list = ', '.join($all_args)
## Smart pointer object construction.
#if $classObj.info.smart_ptr
      $class_name* obj = new ${class_name};
#if $classObj.info.ref_counted
#set $cons_call = $classObj.info.smart_ptr_decl % $class_visitor.getRawName()
      obj->mPtr = ${cons_call}(new ${class_visitor.getRawName()}($arg_list));
#else
      obj->mPtr = ${class_visitor.getRawName()}($arg_list);
#end if
## Normal object construction.
#else
      $class_name* obj = new ${class_name}($arg_list);
#for $count in range(len($classObj.virtual_methods))
#set $callback_name = TemplateHelpers.getCallbackName($classObj.virtual_methods[$count])
      $obj_ref->$callback_name = cb$count;
#end for
#for $count in range(len($classObj.inherited_virtual_methods))
#set $callback_name = TemplateHelpers.getCallbackName($classObj.inherited_virtual_methods[$count])
#set $cb_param_name = 'cb' + str($count + len($classObj.virtual_methods))
      $obj_ref->$callback_name = $cb_param_name;
#end for
## End of normal object construction.
#end if
## Post-call parameter marshaling.
#for $param in $c.parameters
#silent $param[0].accept($param_visitor)
#if $param_visitor.mustMarshal()
      $param_visitor.getPostCallMarshal(); // Post-call marshaling for $param[1]
#end if
#end for
## All constructors return the same thing.
      return obj;
   }

## End of constructor loop.
#end for
## Simple destructor wrapper.
#if $classObj.hasPublicDestructor()
   SHARPPY_API void delete_${class_id}($class_name* self_)
   {
      delete self_;
   }

#end if
## ---------------------------- Non-virtual methods ---------------------------
#for $m in $classObj.non_virtual_methods
#set $method_call = 'self_->%s' + $m.name[0]
$fillMethodWrapperBody($m, $method_call, $classObj, $class_name)
#end for
## ------------------------------ Virtual methods -----------------------------
## XXX: Come up with a way to eliminate the use of a visitor here so that all
## of that is handled by fillMethodWrapperBody().
#set $method_visitor = visitors.CPlusPlusVisitor()
#for $m in $classObj.virtual_methods
## For abstract methods and protected virtual methods, the C wrapper needs to
## act more like a non-virtual.
#if $m.abstract
#set $method_call = 'self_->%s' + $m.name[0]
#elif $m in $classObj.protected_virtual_methods
#set $method_call = 'self_->%s' + $m.name[0] + '_wrapper'
#else
#silent $m.accept($method_visitor)
#set $method_call = 'self_->%s' + $method_visitor.getRawName()
#end if
$fillMethodWrapperBody($m, $method_call, $classObj, $class_name)
#end for
## -------------------------- Sealed virtual methods --------------------------
#for $m in $classObj.sealed_methods
## For sealed virtual methods, the C wrapper needs to act like a non-virtual.
#set $method_call = 'self_->%s' + $m.name[0]
$fillMethodWrapperBody($m, $method_call, $classObj, $class_name)
#end for
## ------------------------------ Static methods ------------------------------
#for $m in $classObj.static_methods
#silent $m.accept($method_visitor)
$fillMethodWrapperBody($m, $method_visitor.getRawName())
#end for
## ---------------------------- Static data members ---------------------------
#set $data_visitor = visitors.CPlusPlusVisitor()
#set $data_type_visitor = visitors.CPlusPlusVisitor()
#for $m in $classObj.static_members
#silent $m.accept($data_visitor)
#silent $m.type.accept($data_type_visitor)
#set $set_name = $data_visitor.getGenericName() + '_set'
#set $get_name = $data_visitor.getGenericName() + '_get'
#if $m.type.must_marshal
#set $native_type = '%s*' % $data_type_visitor.getRawName()
#else
#set $native_type = $data_type_visitor.getRawName()
#end if
   // Wrapper for reading static data member $data_visitor.getRawName()
   SHARPPY_API $native_type ${get_name}()
   {
#if $m.type.must_marshal
## XXX: This probably isn't even close to correct ...
      return &$class_visitor.getRawName()::$m.name[0];
#else
      return $class_visitor.getRawName()::$m.name[0];
#end if
   }

#if not $m.type.const
   // Wrapper for modifying static data member $data_visitor.getRawName()
   SHARPPY_API void ${set_name}($native_type v)
   {
#if $m.type.must_marshal
## XXX: This probably isn't even close to correct ...
      $class_visitor.getRawName()::$m.name[0] = *v;
#else
      $class_visitor.getRawName()::$m.name[0] = v;
#end if
   }
#end if

#end for
## --------------------------- Converter operators ----------------------------
#set $return_visitor = visitors.CPlusPlusReturnVisitor()
#for $o in $classObj.converter_operators
#silent $o.result.accept($return_visitor)
#set $method_call = 'self_->%soperator ' + $return_visitor.getRawName()
$fillMethodWrapperBody($o, $method_call, $classObj, $class_name)
#end for
#del $return_visitor
## ---------------------------- Operator overloads ----------------------------
#for $o in $classObj.member_operators
#set $method_call = 'self_->%soperator' + $o.name[0]
$fillMethodWrapperBody($o, $method_call, $classObj, $class_name)
#end for
#for $o in $classObj.global_operators
#set $method_call = 'operator' + $o.name[0]
$fillMethodWrapperBody($o, $method_call)
#end for
} // extern "C" for $class_visitor.getRawName()

#set $nested_visitor = visitors.CPlusPlusVisitor()
#for $nc in $classObj.nested_classes
#silent $nc.class_.accept($nested_visitor)
// Nested class $nested_visitor.getRawName().
$exportClass($nc)
#end for
#end def

\#include "sharppy.h"
#for $i in $exp_class.includes
\#include <$i>
#end for

$exportClass($exp_class)
