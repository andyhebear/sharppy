using System;
using System.Runtime.InteropServices;

#from TemplateHelpers import getDeclName, getDeclUsage
#from visitors import CSharpVisitor

#set $marsharler_visitor = CSharpVisitor()
#for $m, $c in $marshalers
#silent $c.class_accept($marshaler_visitor)
// Marshaler for $marshaler_visitor.getRawName().
class $marshaler_visitor.getRawName()_Marshaler : ICustomMarshaler
{
}
#end for

#def generateClass($classObj)
#set $bases = []
#set $has_base = False
#set $class_visitor = CSharpVisitor()
#set $base_visitor = CSharpVisitor()
#silent $classObj.class_.accept($class_visitor)
#for $b in $classObj.bases
#silent $b.accept($base_visitor)
#if $base_visitor.getRawName() != $class_visitor.getRawName()
#silent $bases.append($base_visitor.getRawName())
#set $has_base = True
#end if
#end for
#silent bases.append('IDisposable')
#set $b = ', '.join($bases)
public class $class_visitor.getRawName(False) : $b
{
## If we have a base class, it will hold mRawObject.
#if not $has_base
   protected internal IntPtr mRawObject;
   protected bool mWeOwnMemory = false;
#end if

   // Constructors.
#set $cons_visitor = CSharpVisitor()
#for $c in $classObj.constructors
#set $pi_p = ',\n\t'.join(['%s %s' % (getDeclUsage(x[0], $cons_visitor), x[1]) for x in $c.parameters])
   [DllImport("$module", CharSet = CharSet.Ansi)]
   private static extern IntPtr new_${classObj.bridge_name}($pi_p);

#set $p = $pi_p
#set $arg_list = ', '.join([x[1] for x in $c.parameters])
   public ${class_visitor.getRawName(False)}($p)
   {
      mRawObject   = new_${classObj.bridge_name}($arg_list);
      mWeOwnMemory = true;
   }

#end for

   // Destructor.
   public void Dispose()
   {
      delete();
   }

   [DllImport("$module", CharSet = CharSet.Ansi)]
   private extern static void delete_${classObj.bridge_name}(IntPtr obj);

   protected void delete()
   {
      if ( mWeOwnMemory && IntPtr.Zero != mRawObject )
      {
         delete_${classObj.bridge_name}(mRawObject);
         mWeOwnMemory = false;
         mRawObject   = IntPtr.Zero;
      }
   }

   // Overloads.

   // Non-virtual methods.
#for $m in $classObj.non_virtual_methods
#silent $m.accept($class_visitor)
#set $name = $class_visitor.getGenericName()
#set $pi_params = ['%s %s' % (getDeclName(x[0], $class_visitor), x[1]) for x in $m.parameters]
#silent $pi_params[0:0] = ['IntPtr obj']
#set $pi_p = ',\n\t'.join($pi_params)
   [DllImport("$module", CharSet = CharSet.Ansi)]
   private extern static $getDeclName($m.result, $class_visitor) ${name}($pi_p);

#set $p = ', '.join(['%s %s' % (getDeclName(x[0], $class_visitor), x[1]) for x in $m.parameters])
#set $args = [x[1] for x in $m.parameters]
#silent $args[0:0] = ['mRawObject']
#set $arg_list = ', '.join($args)
   public $getDeclName($m.result, $class_visitor) ${m.name[0]}($p)
   {
#if $getDeclName($m.result, $class_visitor) != 'void'
      return ${name}($arg_list);
#else
      ${name}($arg_list);
#end if
   }

#end for

   // Virtual methods.

   // Static methods.

   // Static data.

#set $nested_visitor = CSharpVisitor()
#for $nc in $classObj.nested_classes
#silent $nc.class_.accept($nested_visitor)
   // Nested class $nested_visitor.getRawName().
$generateClass($nc)
#end for
}
#end def

#for $n in $exp_class.class_.namespace
namespace $n
{
#end for

## Begin the recursive process of exporting $exp_class.
$generateClass($exp_class)
#for $n in $exp_class.class_.namespace
}
#end for
