## $Id: class_cs.tmpl,v 1.22 2003-11-10 19:50:36 patrick Exp $

using System;
using System.Runtime.InteropServices;

#from TemplateHelpers import getDeclName, getDeclUsage
#from visitors import CSharpVisitor

#set $marsharler_visitor = CSharpVisitor()
#for $m, $c in $marshalers
#silent $c.class_accept($marshaler_visitor)
// Marshaler for $marshaler_visitor.getRawName().
class $marshaler_visitor.getRawName()_Marshaler : ICustomMarshaler
{
}
#end for

#def generateClass($classObj)
#set $bases = []
#set $has_base = False
#set $class_visitor = CSharpVisitor()
#set $base_visitor = CSharpVisitor()
#set $generic_visitor = CSharpVisitor()
#silent $classObj.class_.accept($class_visitor)
#for $b in $classObj.bases
#silent $b.accept($base_visitor)
##if $base_visitor.getRawName() != $class_visitor.getRawName()
#silent $bases.append($base_visitor.getRawName())
#set $has_base = True
##end if
#end for
#if not $has_base
#silent bases.append('IDisposable')
#end if
#set $b = ', '.join($bases)
public #slurp
#if classObj.class_.abstract
abstract #slurp
#end if
class $class_visitor.getRawName(False) : $b
{
## If we have a base class, it will hold mRawObject.
#if not $has_base
   protected internal IntPtr mRawObject;
   protected bool mWeOwnMemory = false;
#end if

#if not $classObj.class_.abstract
   // Constructors.
#set $cons_visitor = CSharpVisitor()
#set $i = 0
#for $c in $classObj.constructors
#set $cons_name = "new_" + $classObj.bridge_name + "_" + str($i)
#set $i = $i + 1
#set $pi_params = ['%s %s' % (getDeclUsage(x[0], $cons_visitor), x[1]) for x in $c.parameters]
#set $p = ', '.join($pi_params)
#if $classObj.hasVirtualMethods()
#set $i = 0
#for $m in $classObj.virtual_methods
#silent $pi_params.append('[MarshalAs(UnmanagedType.FunctionPtr)] ' + $m.name[0] + 'Delegate d' + str($i))
#set $i = $i + 1
#end for
#end if
#set $pi_p = ',\n\t'.join($pi_params)
   [DllImport("$module", CharSet = CharSet.Ansi)]
   private extern static IntPtr ${cons_name}($pi_p);

#set $cons_args = [x[1] for x in $c.parameters]
   public ${class_visitor.getRawName(False)}($p)
   {
#if $classObj.hasVirtualMethods()
#for $m in $classObj.virtual_methods
      m_${m.name[0]}Delegate = new ${m.name[0]}Delegate($m.name[0]);
#silent $cons_args.append('m_' + $m.name[0] + 'Delegate')
#end for
#end if
#set $arg_list = ', '.join($cons_args)
      mRawObject   = ${cons_name}($arg_list);
      mWeOwnMemory = true;
   }

#end for
   // Internal constructor needed for marshaling purposes.
   internal ${class_visitor.getRawName(False)}(IntPtr instPtr, bool ownMemory)
   {
      mRawObject   = instPtr;
      mWeOwnMemory = ownMemory;
   }

#end if
## If we have a base class, we let it worry about this stuff.
#if not $has_base
   // Destructor.
   public void Dispose()
   {
      delete();
   }

   [DllImport("$module", CharSet = CharSet.Ansi)]
   private extern static void delete_${classObj.bridge_name}(IntPtr obj);

   protected void delete()
   {
      if ( mWeOwnMemory && IntPtr.Zero != mRawObject )
      {
         delete_${classObj.bridge_name}(mRawObject);
         mWeOwnMemory = false;
         mRawObject   = IntPtr.Zero;
      }
   }

#end if
   // Overloads.

#set $method_visitor = CSharpVisitor()
#set $result_visitor = CSharpVisitor()
## ---------------------------- Non-virtual methods ---------------------------
#if $classObj.hasNonVirtualMethods()

   // Start of non-virtual methods.
#for $m in $classObj.non_virtual_methods
#silent $m.accept($method_visitor)
#silent $m.result.accept($result_visitor)
#set $pi_name = $method_visitor.getGenericName()
## XXX: More marshaling is necessary here.
#set $pi_params = ['%s %s' % (getDeclUsage(x[0], $generic_visitor), x[1]) for x in $m.parameters]
#silent $pi_params[0:0] = ['IntPtr obj']
#set $pi_p = ',\n\t'.join($pi_params)
#if $m.result.must_marshal
#set $native_return_type = 'IntPtr'
#else
#set $native_return_type = $result_visitor.getUsage()
#end if
   [DllImport("$module", CharSet = CharSet.Ansi)]
   private extern static $native_return_type ${pi_name}($pi_p);

## XXX: More marshaling is necessary here.
#set $p = ', '.join(['%s %s' % (getDeclUsage(x[0], $generic_visitor), x[1]) for x in $m.parameters])
#set $args = [x[1] for x in $m.parameters]
#silent $args[0:0] = ['mRawObject']
#set $arg_list = ', '.join($args)
   public $result_visitor.getUsage() ${m.name[0]}($p)
   {
#if $m.result.must_marshal
      return new ${result_visitor.getUsage()}(${pi_name}($arg_list), true);
#else
      #if $result_visitor.getRawName() != 'void' then 'return' else ''# ${pi_name}($arg_list);
#end if
   }

#end for
   // End of non-virtual methods.
#end if
## ------------------------------ Virtual methods -----------------------------
#if $classObj.hasVirtualMethods()

   // Start of virtual methods.
#for $m in $classObj.virtual_methods
#silent $m.accept($method_visitor)
#silent $m.result.accept($result_visitor)
#set $method_name = $m.name[0]
#set $pi_name = $method_visitor.getGenericName()
## XXX: More marshaling is necessary here.
#set $pi_params = ['%s %s' % (getDeclUsage(x[0], $generic_visitor), x[1]) for x in $m.parameters]
#set $delegate_params = ', '.join($pi_params)
   // Delegate for the ${method_name}() callback.
## XXX: Filling in the parameter list here could be tricky... marshal, marshal, marshal!
   public delegate $result_visitor.getUsage() ${method_name}Delegate($delegate_params);
   protected ${method_name}Delegate m_${method_name}Delegate;

## XXX: More marshaling is necessary here.
#set $p = ', '.join(['%s %s' % (getDeclUsage(x[0], $generic_visitor), x[1]) for x in $m.parameters])
#if $m.abstract
   public abstract $result_visitor.getUsage() ${method_name}($p);
#else
#if $m.result.must_marshal
#set $native_return_type = 'IntPtr'
#else
#set $native_return_type = $result_visitor.getUsage()
#end if
#silent $pi_params[0:0] = ['IntPtr obj']
#set $pi_p = ',\n\t'.join($pi_params)
   [DllImport("vpr_bridge", CharSet = CharSet.Ansi)]
   private extern static $native_return_type ${pi_name}($pi_p);

   public #if $m.override then 'override' else 'virtual'# $result_visitor.getUsage() ${method_name}($p)
   {
#set $args = [x[1] for x in $m.parameters]
#silent $args[0:0] = ['mRawObject']
#set $arg_list = ', '.join($args)
#if $m.result.must_marshal
      return new ${result_visitor.getUsage()}(${pi_name}($arg_list), true);
#else
      #if $result_visitor.getRawName() != 'void' then 'return' else ''# ${pi_name}($arg_list);
#end if
   }
#end if

#end for
   // End of virtual methods.
#end if
## ------------------------------ Static methods ------------------------------
#if $classObj.hasStaticMethods()

   // Start of static methods.
#for $m in $classObj.static_methods
#silent $m.accept($method_visitor)
#silent $m.result.accept($result_visitor)
#set $pi_name = $method_visitor.getGenericName()
## XXX: More marshaling is necessary here.
#set $pi_params = ['%s %s' % (getDeclUsage(x[0], $generic_visitor), x[1]) for x in $m.parameters]
#set $pi_p = ',\n\t'.join($pi_params)
#if $m.result.must_marshal
#set $native_return_type = 'IntPtr'
#else
#set $native_return_type = $result_visitor.getUsage()
#end if
   [DllImport("$module", CharSet = CharSet.Ansi)]
   private extern static $native_return_type ${pi_name}($pi_p);

## XXX: More marshaling is necessary here.
#set $p = ', '.join(['%s %s' % (getDeclUsage(x[0], $generic_visitor), x[1]) for x in $m.parameters])
#set $args = [x[1] for x in $m.parameters]
#set $arg_list = ', '.join($args)
   public static $result_visitor.getUsage() ${m.name[0]}($p)
   {
#if $m.result.must_marshal
      return new ${result_visitor.getUsage()}(${pi_name}($arg_list), true);
#else
      #if $result_visitor.getRawName() != 'void' then 'return' else ''# ${pi_name}($arg_list);
#end if
   }

#end for
   // End of static methods.
#end if
## ---------------------------- Static data members ---------------------------
#if $classObj.hasStaticData()

   // Start of static data.
#set $data_visitor = CSharpVisitor()
#set $data_type_visitor = CSharpVisitor()
#for $m in $classObj.static_members
#silent $m.accept($data_visitor)
#silent $m.type.accept($data_type_visitor)
#set $set_name = $data_visitor.getGenericName() + '_set'
#set $get_name = $data_visitor.getGenericName() + '_get'
#if $m.type.must_marshal
#set $native_type = 'IntPtr'
#else
#set $native_type = $data_type_visitor.getUsage()
#end if
   // Getter function for $data_visitor.getRawName()
   [DllImport("$module", CharSet = CharSet.Ansi)]
   private extern static $native_type ${get_name}();

#if not $m.type.const
   // Setter function for $data_visitor.getRawName()
   [DllImport("$module", CharSet = CharSet.Ansi)]
   private extern static void ${set_name}($native_type v);
#end if

   // Property for $data_visitor.getRawName()
   public static $data_type_visitor.getUsage() $m.name[0]
   {
#if $m.type.must_marshal
## XXX: Allocating a new object for every get() call seems wasteful.
      get { return new ${data_type_visitor.getUsage()}(${get_name}(), false); }
#if not $m.type.const
      set { ${set_name}(value.mRawObject); }
#end if
#else
      get { return ${get_name}(); }
#if not $m.type.const
      set { ${set_name}(value); }
#end if
#end if
   }

#end for
   // End of static data.
#end if

## ---------------------------- Nested enumerations ---------------------------
#set $nested_visitor = CSharpVisitor()
#for $ne in $classObj.nested_enums
#silent $ne.enum.accept($nested_visitor)
#set $enum_values = ["%s = %d" % (v, $ne.enum.values[v]) for v in $ne.enum.values.keys()]
#set $body = ', '.join($enum_values)
   // Nested enumeration $nested_visitor.getRawName().
   public enum $nested_visitor.getRawName(False)
   {
      $body
   };
#end for

#for $nc in $classObj.nested_classes
#silent $nc.class_.accept($nested_visitor)
   // Nested class $nested_visitor.getRawName().
#if $nc.isInterface()
$generateInterface($nc)
#else
$generateClass($nc)
#end if
#end for
} // class $class_visitor.getRawName()
#end def

#def generateInterface($classObj)
#set $bases = []
#set $has_base = False
#set $class_visitor = CSharpVisitor()
#set $base_visitor = CSharpVisitor()
#set $generic_visitor = CSharpVisitor()
#silent $classObj.class_.accept($class_visitor)
#for $b in $classObj.bases
#silent $b.accept($base_visitor)
##if $base_visitor.getRawName() != $class_visitor.getRawName()
#silent $bases.append($base_visitor.getRawName())
#set $has_base = True
##end if
#end for
public interface $class_visitor.getRawName(False)
#if $has_base
#set $base_list = ', '.join($bases)
   : $base_list
#end if
{
## ------------------------------ Virtual methods -----------------------------
#if $classObj.hasVirtualMethods()
#set $method_visitor = CSharpVisitor()
#set $result_visitor = CSharpVisitor()
#for $m in $classObj.virtual_methods
#silent $m.accept($method_visitor)
#silent $m.result.accept($result_visitor)
#set $method_name = $m.name[0]
#set $p = ', '.join(['%s %s' % (getDeclUsage(x[0], $generic_visitor), x[1]) for x in $m.parameters])
   public $result_visitor.getUsage() ${method_name}($p);

#end for
#end if
}
#end def

#for $n in $exp_class.class_.namespace
namespace $n
{
#end for

## Begin the recursive process of exporting $exp_class.
#if $exp_class.isInterface()
$generateInterface($exp_class)
#else
$generateClass($exp_class)
#end if
#for $n in $exp_class.class_.namespace
} // namespace $n
#end for
