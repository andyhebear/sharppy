# This is derived from the Pyste version of ClassExporter.py.
# See http://www.boost.org/ for more information.

import exporters
from Exporter import Exporter
from declarations import *
from settings import *
from policies import *
from SingleCodeUnit import SingleCodeUnit
from EnumExporter import EnumExporter
from utils import makeid, enumerate, generateUniqueName
import copy
import exporterutils
import re

#==============================================================================
# ReferenceTypeExporter
#==============================================================================
class ReferenceTypeExporter(Exporter):
    'Generates C# P/Invoke bridging code to export a class declaration.'
 
    def __init__(self, info, parser_tail=None):
        Exporter.__init__(self, info, parser_tail)
        # sections of code
        self.sections = {}
        # template: each item in the list is an item into the class_<...> 
        # section.
        self.sections['template'] = []  
        # constructor: each item in the list is a parameter to the class_ 
        # constructor, like class_<C>(...)
        self.sections['constructor'] = []
        # inside: everything within the class_<> statement        
        self.sections['inside'] = []

        self.exportable_methods = {}

        # XXX: Delete me later.
        self.sections['scope'] = []

        # Bridge declarations.
        self.sections['declaration'] = []
        self.sections['declaration-outside'] = []
        self.sections['include'] = []
        self.sections['virtual-method-wrappers'] = []
        # a list of Constructor instances
        self.constructors = []
        self.no_init      = False
        self.non_copyable = False
        self.callback_typedefs = []
        self.wrapper_generator = None
        # a list of code units, generated by nested declarations
        self.nested_codeunits = []

    def ClassName(self):
        return makeid(self.class_.FullName())

    def BridgeName(self):
        return makeid(self.class_.FullName()) + '_bridge'

    def HolderName(self):
        return makeid(self.class_.FullName()) + '_holder'

    def Name(self):
        return self.info.name


    def SetDeclarations(self, declarations):
        Exporter.SetDeclarations(self, declarations)
        if self.declarations:
            decl = self.GetDeclaration(self.info.name)
            if isinstance(decl, Typedef):
                self.class_ = self.GetDeclaration(decl.type.name)
                if not self.info.rename:
                    self.info.rename = decl.name
            else:
                self.class_ = decl
            self.class_ = copy.deepcopy(self.class_)
        else:
            self.class_ = None
        self.wrapper_generator = _VirtualWrapperGenerator(self.class_, self.ClassBases(), self.info)
        
        
    def ClassBases(self):
        all_bases = []       
        for level in self.class_.hierarchy:
            for base in level:
                all_bases.append(base)
        return [self.GetDeclaration(x.name) for x in all_bases] 

    
    def Order(self):
        '''Return the TOTAL number of bases that this class has, including the
        bases' bases.  Do this because base classes must be instantialized
        before the derived classes in the module definition.  
        '''
        num_bases = len(self.ClassBases())
        return num_bases, self.class_.FullName()
        
    
    def Export(self, codeunit, exported_names):
        self.InheritMethods(exported_names)
        self.MakeNonVirtual()
        if not self.info.exclude:
            self.ExportBasics()
            self.ExportBases(exported_names)
            self.ExportConstructors()
            self.ExportVirtualMethods()
            self.ExportMethods()
            self.ExportVirtualMethodWrappers()
#            self.ExportMethodWrappers()
            self.ExportOperators()
            self.ExportNestedClasses(exported_names)
            self.ExportNestedEnums(exported_names)
            self.ExportSmartPointer()
            self.ExportOpaquePointerPolicies()
            self.Write(codeunit)
            exported_names[self.Name()] = 1


    def InheritMethods(self, exported_names):
        '''Go up in the class hierarchy looking for classes that were not
        exported yet, and then add their public members to this classes
        members, as if they were members of this class. This allows the user to
        just export one type and automatically get all the members from the
        base classes.
        '''
        valid_members = (Method, ClassVariable, NestedClass, ClassEnumeration)
            # these don't work INVESTIGATE!: (ClassOperator, ConverterOperator)
        fullnames = [x.FullName() for x in self.class_]
        pointers = [x.PointerDeclaration(True) for x in self.class_ if isinstance(x, Method)]
        fullnames = dict([(x, None) for x in fullnames])
        pointers = dict([(x, None) for x in pointers])
        for level in self.class_.hierarchy:
            level_exported = False
            for base in level:
                base = self.GetDeclaration(base.name)
                if base.FullName() not in exported_names:
                    for member in base:
                        if type(member) in valid_members:
                            member_copy = copy.deepcopy(member)   
                            member_copy.class_ = self.class_.FullName()
                            if isinstance(member_copy, Method):
                                pointer = member_copy.PointerDeclaration(True)
                                if pointer not in pointers:
                                    self.class_.AddMember(member)
                                    pointers[pointer] = None
                            elif member_copy.FullName() not in fullnames:
                                self.class_.AddMember(member)        
                else:
                    level_exported = True
            if level_exported:
                break
        def IsValid(member):
            return isinstance(member, valid_members) and member.visibility == Scope.public
        self.public_members = [x for x in self.class_ if IsValid(x)] 

    def Write(self, codeunit):
        self.WriteCPlusPlus(codeunit)
        self.WriteCSharp(codeunit)

    def WriteCPlusPlus(self, codeunit):
        'Generates the C++ and C code needed for the bridging.'

        def GetResultType(result):
            result_type_name = result.name
            by_value         = True
            is_fundamental   = True

            if result_type_name != 'void':
                by_value = not isinstance(result, PointerType)

                # If we are returning by value and we do not have a fundamental
                # type being returned, convert things to returning by pointer
                # instead.
                if by_value and not isinstance(result, FundamentalType):
                    result_type_name += '*'
                    by_value = False
                    is_fundamental = False

            return result_type_name, by_value, is_fundamental

        indent = self.INDENT
        sharppy_ns = namespaces.sharppy
        code = ''
        # begin a scope for this class if needed
        nested_codeunits = self.nested_codeunits
        needs_scope = nested_codeunits
#        if needs_scope:
#            scope_name = self.ScopeName()
#            code += indent + boost_ns + 'scope* %s = new %sscope(\n' %\
#                (scope_name, boost_ns)
        # export the template section
        template_params = ', '.join(self.sections['template'])

        cb_type_list = [x[0] for x in self.callback_typedefs]
        callback_args = ['%s c%d' % (cb_type_list[i], i) for i in range(0, len(cb_type_list))]

        # If this class has virtual methods, then we need to use the bridge
        # name in various places.  Otherwise, we won't have a bridge, and it
        # would be bad to try to refer to it.
        wrapper_class_type = self.class_.FullName()
        wrapper_class_name = self.ClassName()
        if self.HasVirtualMethods():
            wrapper_class_name = self.BridgeName()
            wrapper_class_type = self.BridgeName()

        # XXX: I'm not sure about the handling of copy constructors here.
        for i in range(0, len(self.constructors)):
            c = self.constructors[i]
            cons_params = ['%s p%d' % (c.parameters[j].FullName(), j) for j in range(0, len(c.parameters))]
            arg_list = []
            for j in range(0, len(cons_params)):
                arg_list.append('p' + str(j))

            cons_wrapper_name = "%s_c%d" % (wrapper_class_name, i)

            # If this is a copy constructor, prepend "copy_" to the wrapper
            # name.
            if c.IsCopy():
                cons_wrapper_name = "copy_%s" % wrapper_class_name
            # If this is not the copy constructor, we need to append the
            # virtual function callback arguments to the parameter list.
            else:
                cons_params.extend(callback_args)

            cons_params = ', '.join(cons_params)
            arg_list = ', '.join(arg_list)

            code += 'SHARPPY_API %s* %s(%s)\n' % \
                    (self.class_.FullName(), cons_wrapper_name, cons_params)
            code += '{\n'
            code += indent + '%s* o = new %s(%s);\n' % \
                    (wrapper_class_type, wrapper_class_type, arg_list)

            # Initialize all virtual method callbacks (if there are any).
            if len(self.callback_typedefs) > 0:
                for j in range(0, len(self.callback_typedefs)):
                    if c.IsCopy():
                        code += indent + 'o->%s = p0.%s;\n' % (self.callback_typedefs[j][1], self.callback_typedefs[j][1])
                    else:
                        code += indent + 'o->%s = c%d;\n' % (self.callback_typedefs[j][1], j)

            code += indent + 'return (%s*) o;\n' % (wrapper_class_type)
            code += '}\n\n'

        code += 'SHARPPY_API void delete_%s(%s* self_)\n' % (wrapper_class_name, self.class_.FullName())
        code += '{\n'
        code += indent + 'delete self_;\n'
        code += '}\n\n'
        # export the constructor section
        constructor_params = ', '.join(self.sections['constructor'])

        for method_name, methods in self.exportable_methods.items():
            print method_name, "will be exported"
            for i in range(0, len(methods)):
                method = methods[i]
                print "Working on %s(%s)" % (method_name, method.parameters)
                method_info = self.info[method.name]

                # The C wrapper function will be named based on the parameter
                # type list.  This gives us a guaranteed unique name.
                param_id = "_".join(generateUniqueName(method.parameters))
                if param_id:
                    param_id = "_" + param_id
                c_wrapper = "%s_%s%s" % (wrapper_class_name, method_name, param_id)

                if method.minArgs != method.maxArgs:
                    c_wrapper += "_%d" % i
                    print "We'll need some extra functions for this one"

                params = []   # The list of typed parameters for the C wrapper
                args = []     # The list of arguments passed to the C++ method
                for i in range(0, len(method.parameters)):
                    param = method.parameters[i]
                    params.append("%s p%d" % (param.FullName(), i))
                    args.append("p%d" % i)

                param_list = ", ".join(params)
                arg_list   = ", ".join(args)
                if param_list:
                    param_list = ", " + param_list

                # Set up the information we need for constructing the wrapper
                # function.
                result_type, by_value, is_fund = GetResultType(method.result)
                call_str = "self->%s(%s)" % (method.name, arg_list)

                code += "SHARPPY_API %s %s(%s* self_%s)\n" %\
                        (result_type, c_wrapper, wrapper_class_name, param_list)
                code += "{\n"

                # Deal with the case of returning a non-fundamental type as a
                # pointer created via the copy constructor.
                if not is_fund:
                    code += indent + "return new %s(%s);\n" % \
                            (method.result.FullName(), call_str)
                # Otherwise, just operate as normal.
                else:
                    return_str = 'return '
                    if result_type == 'void':
                        return_str = ''
                    code += indent + "%sself->%s(%s);\n" % (return_str, method.name, arg_list)

                code += "}\n\n"

        vars = [x for x in self.public_members if isinstance(x, Variable)]
        for var in vars:
            if self.info[var.name].exclude: 
                continue
            name = self.info[var.name].rename or var.name
            print "Working on", name
            fullname = var.FullName()

            self_arg = "%s* self_" % wrapper_class_type
            self_use = "self_->"
            if var.static:
                self_arg = ''
                self_use = ''

            result_type, by_value, is_fund = GetResultType(var.type)
            call_str = "%s%s" % (self_use, var.name)
            
            if not is_fund:
                call_str = "new %s(%s)" % (var.type.name, call_str)

            code += "SHARPPY_API %s %s_%s_get(%s)\n" %\
                    (result_type, wrapper_class_name, name, self_arg)
            code += "{\n"
            code += indent + "return %s;\n" % call_str
            code += "}\n\n"

            if not var.type.const:
                if self_arg:
                    self_arg += ", "
                code += "SHARPPY_API void %s_set(%s%s v)\n" %\
                        (makeid(var.FullName()), self_arg,
                         var.type.FullName())
                code += "{\n"
                code += indent + "%s%s = v;\n" % (self_use, var.name)
                code += "}\n\n"

        # export the inside section
        in_indent = indent*2
        for line in self.sections['inside']:
            code += in_indent + line + '\n' 

        if needs_scope:
            for line in self.sections['scope']:
                print "DEBUG:", line
#                code += indent + line + '\n'
            # write the contents of the nested classes
            for nested_unit in nested_codeunits:
                code += '\n' + nested_unit.SectionCPlusPlus('c-wrappers')
            # close the scope
#            code += indent + 'delete %s;\n' % scope_name

        if self.HasVirtualMethods():
            funcs = []
            for method in self.wrapper_generator.virtual_methods:
                if not self.wrapper_generator.info[method.name].exclude:
                    funcs.append(self.wrapper_generator.VirtualMethodDefault(method, indent))
            code += '\n'.join(funcs)

        # Write to the C wrappers section in the codeunit.
        codeunit.WriteCPlusPlus('c-wrappers', code + '\n')

        # Write the bridge declarations to the codeunit.
        declarations = '\n'.join(self.sections['declaration'])
        for nested_unit in nested_codeunits:
            declarations += nested_unit.SectionCPlusPlus('declaration')
        if declarations:
            codeunit.WriteCPlusPlus('declaration', declarations + '\n')
        declarations_outside = '\n'.join(self.sections['declaration-outside'])
        if declarations_outside:
            codeunit.WriteCPlusPlus('declaration-outside', declarations_outside + '\n')

        # write the includes to the codeunit
        includes = '\n'.join(self.sections['include'])
        for nested_unit in nested_codeunits:
            includes += nested_unit.SectionCPlusPlus('include')
        if includes:
            codeunit.WriteCPlusPlus('include', includes)

    def WriteCSharp(self, codeunit):
        'Generates the C# needed for the bridging.'
        indent = self.INDENT

    def Add(self, section, item):
        'Add the item into the corresponding section'
        self.sections[section].append(item)

        
    def ExportBasics(self):
        '''Export the name of the class and its class_ statement.'''
        self.base_class = self.class_.FullName()
        name = self.info.rename or self.class_.name
        self.Add('constructor', '"%s"' % name)
        
        
    def ExportBases(self, exported_names):
        'Expose the bases of the class into the template section'        
        hierarchy = self.class_.hierarchy
        exported = []
        for level in hierarchy:
            for base in level:
                if base.visibility == Scope.public and base.name in exported_names:
                    exported.append(base.name)
            if exported:
                break
        if exported:
            code = 'bases< %s > ' %  (', '.join(exported))
            self.Add('template', code)         


    def ExportConstructors(self):
        '''
        Exports all the public contructors of the class, plus indicates if the 
        class is noncopyable.
        '''
        indent = self.INDENT
        constructors = [x for x in self.public_members if isinstance(x, Constructor)]

        # don't export the copy constructor if the class is abstract
        if self.class_.abstract:
            for cons in constructors:
                if cons.IsCopy():
                    constructors.remove(cons)
                    break

        self.constructors = constructors[:]

        # At this point, if we have no constructors left, then this class
        # cannot be instantiated.
        if not constructors:
            # declare no_init
            self.no_init = True

        # Check if the class is copyable.
        if not self.class_.HasCopyConstructor() or self.class_.abstract:
            self.non_copyable = True

    def OverloadName(self, method):
        'Returns the name of the overloads struct for the given method'
        name = makeid(method.FullName())
        overloads = '_overloads_%i_%i' % (method.minArgs, method.maxArgs)    
        return name + overloads

    
    def GetAddedMethods(self):
        added_methods = self.info.__added__
        result = []
        if added_methods:
            for name, rename in added_methods:
                decl = self.GetDeclaration(name)
                self.info[name].rename = rename
                result.append(decl)
        return result

                
    def ExportMethods(self):
        '''Export all the non-virtual methods of this class, plus any function
        that is to be exported as a method'''
            
        declared = {}
        def DeclareOverloads(m):
            'Declares the macro for the generation of the overloads'
            if (isinstance(m, Method) and m.static) or type(m) == Function:
                func = m.FullName()
                macro = 'BOOST_PYTHON_FUNCTION_OVERLOADS'
            else:
                func = m.name
                macro = 'BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS' 
            code = '%s(%s, %s, %i, %i)\n' % (macro, self.OverloadName(m), func, m.minArgs, m.maxArgs)
            if code not in declared:
                declared[code] = True
                self.Add('declaration', code)


        def Pointer(m):
            'returns the correct pointer declaration for the method m'
            # check if this method has a wrapper set for him
            wrapper = self.info[m.name].wrapper
            if wrapper:
                return '&' + wrapper.FullName()
            else:
                return m.PointerDeclaration() 

        def IsExportable(m):
            'Returns true if the given method is exportable by this routine'
            ignore = (Constructor, ClassOperator, Destructor)
            return isinstance(m, Function) and not isinstance(m, ignore) and not m.virtual        

        methods = [x for x in self.public_members if IsExportable(x)]
        methods.extend(self.GetAddedMethods())

#        staticmethods = {}

        for method in methods:
            method_info = self.info[method.name]

            # skip this method if it was excluded by the user
            if method_info.exclude:
                continue 

            # rename the method if the user requested
            name = method_info.rename or method.name

            # Use a list to keep track of each method since overloading can
            # occur without using default arguments.
            if not self.exportable_methods.has_key(name):
                self.exportable_methods[name] = []
            self.exportable_methods[name].append(method)

            # warn the user if this method needs a policy and doesn't have one
            method_info.policy = exporterutils.HandlePolicy(method, method_info.policy)
            
            # check for policies
 #           policy = method_info.policy or ''
 #           if policy:
 #               policy = ', %s()' % (policy.Code())
            # check for overloads
#            overload = ''
            if method.minArgs != method.maxArgs:
                # add the overloads for this method
                DeclareOverloads(method)
#                overload_name = self.OverloadName(method)
#                overload = ', %s%s()' % (namespaces.sharppy, overload_name)
        
#            # build the .def string to export the method
#            pointer = Pointer(method)
#            code = '.def("%s", %s' % (name, pointer)
#            code += policy
#            code += overload
#            code += ')'
#            self.Add('inside', code)
#            # static method
#            if isinstance(method, Method) and method.static:
#                staticmethods[name] = 1
            # add wrapper code if this method has one
            wrapper = method_info.wrapper
            if wrapper and wrapper.code:
                self.Add('declaration', wrapper.code)
        
#        # export staticmethod statements
#        for name in staticmethods:
#            code = '.staticmethod("%s")' % name
#            self.Add('inside', code) 


                
    def MakeNonVirtual(self):
        '''Make all methods that the user indicated to no_override no more virtual, delegating their
        export to the ExportMethods routine'''
        for member in self.class_:
            if type(member) == Method and member.virtual:
                member.virtual = not self.info[member.name].no_override 


    def HasVirtualMethods(self):
        # Check to see if this class has any virtual methods.
        for member in self.class_:
            if type(member) == Method and member.virtual:
                return True

        return False

    def ExportVirtualMethods(self):        
        holder = self.info.holder
        if self.HasVirtualMethods():
#            if holder:
#                self.Add('template', holder(self.wrapper_generator.FullName()))
#            else:
#                self.Add('template', self.wrapper_generator.FullName())
#            for definition in self.wrapper_generator.GenerateDefinitions():
#                self.Add('inside', definition)
            self.Add('declaration', self.wrapper_generator.GenerateVirtualWrapper(self.INDENT))
        else:
            if holder:
                self.Add('template', holder(self.class_.FullName()))

    def ExportVirtualMethodWrappers(self):        
        if self.HasVirtualMethods():
            self.callback_typedefs = self.wrapper_generator.callback_typedefs

    # Operators natively supported by C#.
    CSHARP_SUPPORTED_OPERATORS = '+ - * / % ^ & ! ~ | < > == != <= >= << >>' \
                                 '&& || += -= *= /= %= ^= &= |= <<= >>='.split()
    # Create a map for faster lookup.
    CSHARP_SUPPORTED_OPERATORS = dict(zip(CSHARP_SUPPORTED_OPERATORS,
                                      range(len(CSHARP_SUPPORTED_OPERATORS))))

#    # A dictionary of operators that are not directly supported by boost, but
#    # can be exposed simply as a function with a special name.
#    CSHARP_RENAME_OPERATORS = {
#        '()' : '__call__',
#    }
#
#    # converters which have a special name in python
#    # it's a map of a regular expression of the converter's result to the
#    # appropriate python name
#    SPECIAL_CONVERTERS = {
#        re.compile(r'(const)?\s*double$') : '__float__',
#        re.compile(r'(const)?\s*float$') : '__float__',
#        re.compile(r'(const)?\s*int$') : '__int__',
#        re.compile(r'(const)?\s*long$') : '__long__',
#        re.compile(r'(const)?\s*char\s*\*?$') : '__str__',
#        re.compile(r'(const)?.*::basic_string<.*>\s*(\*|\&)?$') : '__str__',
#    }
        
    
    def ExportOperators(self):
        'Export all member operators and free operators related to this class'
        
        def GetFreeOperators():
            'Get all the free (global) operators related to this class'
            operators = []
            for decl in self.declarations:
                if isinstance(decl, Operator):
                    # check if one of the params is this class
                    for param in decl.parameters:
                        if param.name == self.class_.FullName():
                            operators.append(decl)
                            break
            return operators

        def GetOperand(param):
            'Returns the operand of this parameter (either "self", or "other<type>")'
            if param.name == self.class_.FullName():
                return 'self'
            else:
                return ('other< %s >()' % param.name)


        def HandleSpecialOperator(operator):
            # gatter information about the operator and its parameters
            result_name = operator.result.name                        
            param1_name = ''
            if operator.parameters:
                param1_name = operator.parameters[0].name
                
            # check for str
            ostream = 'basic_ostream'
            is_str = result_name.find(ostream) != -1 and param1_name.find(ostream) != -1
            if is_str:
                namespace = 'self_ns::'
                self_ = 'self'
                return '.def(%sstr(%s))' % (namespace, self_)

            # is not a special operator
            return None
                

        
        frees = GetFreeOperators()
        members = [x for x in self.public_members if type(x) == ClassOperator]
        all_operators = frees + members
        operators = [x for x in all_operators if not self.info['operator'][x.name].exclude]
        
        for operator in operators:
            # gatter information about the operator, for use later
            wrapper = self.info['operator'][operator.name].wrapper
            if wrapper:
                pointer = '&' + wrapper.FullName()
                if wrapper.code:
                    self.Add('declaration', wrapper.code)
            else:
                pointer = operator.PointerDeclaration()                 
            rename = self.info['operator'][operator.name].rename

            # check if this operator will be exported as a method
            export_as_method = wrapper or rename #or operator.name in self.BOOST_RENAME_OPERATORS
            
            # check if this operator has a special representation in boost
            special_code = HandleSpecialOperator(operator)
            has_special_representation = special_code is not None
            
            if export_as_method:
                # export this operator as a normal method, renaming or using the given wrapper
                if not rename:
                    if wrapper:
                        rename = wrapper.name
#                    else:
#                        rename = self.BOOST_RENAME_OPERATORS[operator.name]
                policy = ''
                policy_obj = self.info['operator'][operator.name].policy
                if policy_obj:
                    policy = ', %s()' % policy_obj.Code() 
                self.Add('inside', '.def("%s", %s%s)' % (rename, pointer, policy))
            
            elif has_special_representation:
                self.Add('inside', special_code)
                
            elif operator.name in self.CSHARP_SUPPORTED_OPERATORS:
                # export this operator using boost's facilities
                op = operator
                is_unary = isinstance(op, Operator) and len(op.parameters) == 1 or\
                           isinstance(op, ClassOperator) and len(op.parameters) == 0
                if is_unary:
                    self.Add('inside', '.def( %sself )' % \
                        (operator.name))
                else:
                    # binary operator
                    if len(operator.parameters) == 2:
                        left_operand = GetOperand(operator.parameters[0])
                        right_operand = GetOperand(operator.parameters[1])
                    else:
                        left_operand = 'self'
                        right_operand = GetOperand(operator.parameters[0])
                    self.Add('inside', '.def( %s %s %s )' % \
                        (left_operand, operator.name, right_operand))

        # export the converters.
        # export them as simple functions with a pre-determined name

        converters = [x for x in self.public_members if type(x) == ConverterOperator]
                
        def ConverterMethodName(converter):
            result_fullname = converter.result.FullName()
            result_name = converter.result.name
            for regex, method_name in self.SPECIAL_CONVERTERS.items():
                if regex.match(result_fullname):
                    return method_name
            else:
                # extract the last name from the full name
                result_name = makeid(result_name)
                return 'to_' + result_name
            
        for converter in converters:
            info = self.info['operator'][converter.result.FullName()]
            # check if this operator should be excluded
            if info.exclude:
                continue
            
            special_code = HandleSpecialOperator(converter)
            if info.rename or not special_code:
                # export as method
                name = info.rename or ConverterMethodName(converter)
                pointer = converter.PointerDeclaration()
                policy_code = ''
                if info.policy:
                    policy_code = ', %s()' % info.policy.Code()
                self.Add('inside', '.def("%s", %s%s)' % (name, pointer, policy_code))
                    
            elif special_code:
                self.Add('inside', special_code)



    def ExportNestedClasses(self, exported_names):
        nested_classes = [x for x in self.public_members if isinstance(x, NestedClass)]
        for nested_class in nested_classes:
            nested_info = self.info[nested_class.name]
            nested_info.include = self.info.include
            nested_info.name = nested_class.FullName()
            exporter = ReferenceTypeExporter(nested_info)
            exporter.SetDeclarations(self.declarations)
            codeunit = SingleCodeUnit(None, None, None)
            exporter.Export(codeunit, exported_names)
            self.nested_codeunits.append(codeunit)


    def ExportNestedEnums(self, exported_names):
        nested_enums = [x for x in self.public_members if isinstance(x, ClassEnumeration)]
        for enum in nested_enums:
            enum_info = self.info[enum.name]
            enum_info.include = self.info.include
            enum_info.name = enum.FullName()
            exporter = EnumExporter(enum_info)
            exporter.SetDeclarations(self.declarations)
            codeunit = SingleCodeUnit(None, None, None)
            exporter.Export(codeunit, exported_names)
            self.nested_codeunits.append(codeunit)


    def ExportSmartPointer(self):
        smart_ptr = self.info.smart_ptr
        if smart_ptr:
            class_name = self.class_.FullName()
            smart_ptr = smart_ptr % class_name
            self.Add('scope', 'register_ptr_to_python< %s >();' % (smart_ptr))
            

    def ExportOpaquePointerPolicies(self):
        # check all methods for 'return_opaque_pointer' policies
        methods = [x for x in self.public_members if isinstance(x, Method)]
        for method in methods:
            return_opaque_policy = return_value_policy(return_opaque_pointer)
            if self.info[method.name].policy == return_opaque_policy:
                macro = exporterutils.EspecializeTypeID(method.result.name) 
                if macro:
                    self.Add('declaration-outside', macro)


#==============================================================================
# Virtual Wrapper utils
#==============================================================================

def _ParamsInfo(m, count=None):
    if count is None:
        count = len(m.parameters)
    param_names = ['p%i' % i for i in range(count)]
    param_types = [x.FullName() for x in m.parameters[:count]]
    params = ['%s %s' % (t, n) for t, n in zip(param_types, param_names)]
    #for i, p in enumerate(m.parameters[:count]):
    #    if p.default is not None:
    #        #params[i] += '=%s' % p.default
    #        params[i] += '=%s' % (p.name + '()')
    params = ', '.join(params) 
    return params, param_names, param_types

            
class _VirtualWrapperGenerator(object):
    'Generates code to export the virtual methods of the given class'

    def __init__(self, class_, bases, info):
        self.class_ = copy.deepcopy(class_)
        self.bases = bases[:]
        self.info = info
        self.bridge_name = makeid(class_.FullName()) + '_bridge'
        self.virtual_methods = None
        self._method_count = {}
        self.callback_typedefs = []
        self.GenerateVirtualMethods()

    def DefaultImplementationNames(self, method):
        '''
        Returns a list of default implementations for this method, one for
        each number of default arguments. Always returns at least one name,
        and return from the one with most arguments to the one with the least.
        '''
        base_name = '%s_%s' % (makeid(self.class_.FullName()), method.name)
        minArgs = method.minArgs
        maxArgs = method.maxArgs
        if minArgs == maxArgs:
            return [base_name]
        else:
            return [base_name + ('_%i' % i) for i in range(minArgs, maxArgs+1)]                


    def Declaration(self, method, indent):
        '''
        Returns a string with the declarations of the virtual wrapper and its
        default implementations. This string must be put inside the Wrapper
        body.        
        '''
        sharppy = namespaces.sharppy
        rename = self.info[method.name].rename or method.name
        result = method.result.FullName()
        return_str = 'return '
        if result == 'void':
            return_str = ''
        params, param_names, param_types = _ParamsInfo(method)
        constantness = ''
        if method.const:
            constantness = ' const'

        # C# virtual function callback.
        decl  = indent + '%s %s(%s)%s%s\n' % (result, method.name, params, constantness, method.Exceptions())
        decl += indent + '{\n'
        param_names_str = ', '.join(param_names)
        decl += indent*2 + '%s%s_callback(%s);\n' %\
            (return_str, method.name, param_names_str)
        decl += indent + '}\n'
        return decl

    def VirtualMethodDefault(self, method, indent):
        # default implementations (with overloading)
        def DefaultImpl(method, param_names):
            'Return the body of a default implementation wrapper'
            wrapper = self.info[method.name].wrapper
            if not wrapper:
                # return the default implementation of the class
                if method.abstract:
                    s = indent + 'PyErr_SetString(PyExc_RuntimeError, "pure virtual function called");\n' +\
                        indent + 'throw_error_already_set();\n' 
                    params = ', '.join(param_names)
                    s += indent2 + '%sself_->%s(%s);\n' % \
                        (return_str, method.name, params)
                    return s
                else:                 
                    return indent + '%sself_->%s(%s);\n' % \
                        (return_str, method.FullName(), ', '.join(param_names)) 
            else:
                # return a call for the wrapper
                params = ', '.join(['this'] + param_names)
                return indent + '%sself_->%s(%s);\n' % (return_str, wrapper.FullName(), params)

        func = ''
        if method.visibility != Scope.private:
            minArgs = method.minArgs
            maxArgs = method.maxArgs
            impl_names = self.DefaultImplementationNames(method)

            result = method.result.FullName()
            return_str = 'return '
            if result == 'void':
                return_str = ''

            for impl_name, argNum in zip(impl_names, range(minArgs, maxArgs+1)): 
                params, param_names, param_types = _ParamsInfo(method, argNum)            
                func += 'SHARPPY_API %s %s(%s* self_, %s)\n' % (result, impl_name, self.class_.FullName(), params)
                func += '{\n'
                func += DefaultImpl(method, param_names)
                func += '}\n'
        return func
            

    def MethodDefinition(self, method):
        '''Returns a list of lines, which should be put inside the class_
        statement to export this method.'''
        # dont define abstract methods
        sharppy = namespaces.sharppy
        rename = self.info[method.name].rename or method.name
        default_names = self.DefaultImplementationNames(method)
        class_name = self.class_.FullName()
        bridge_name = sharppy + self.bridge_name
        result = method.result.FullName()
        is_method_unique = method.is_unique
        constantness = ''
        if method.const:
            constantness = ' const'
        
        # create a list of default-impl pointers
        minArgs = method.minArgs
        maxArgs = method.maxArgs 
        if is_method_unique:
            default_pointers = ['&%s::%s' % (bridge_name, x) for x in default_names]
        else:
            default_pointers = []
            for impl_name, argNum in zip(default_names, range(minArgs, maxArgs+1)):
                param_list = [x.FullName() for x in method.parameters[:argNum]]
                params = ', '.join(param_list)             
                signature = '%s (%s::*)(%s)%s' % (result, bridge_name, params, constantness)
                default_pointer = '(%s)&%s::%s' % (signature, bridge_name, impl_name)
                default_pointers.append(default_pointer)
            
        # get the pointer of the method
        pointer = method.PointerDeclaration()

        # Add policy to overloaded methods also
        policy = self.info[method.name].policy or ''
        if policy:
            policy = ', %s()' % (policy.Code())

        # generate the defs
        definitions = []
        # basic def
        definitions.append('.def("%s", %s, %s%s)' % (rename, pointer, default_pointers[-1], policy))
        for default_pointer in default_pointers[:-1]:
            definitions.append('.def("%s", %s%s)' % (rename, default_pointer, policy))
        return definitions

    
    def FullName(self):
        return namespaces.sharppy + self.bridge_name


    def GenerateVirtualMethods(self):
        '''To correctly export all virtual methods, we must also make wrappers
        for the virtual methods of the bases of this class, as if the methods
        were from this class itself.
        This method creates the instance variable self.virtual_methods.
        '''        
        def IsVirtual(m):
            return type(m) is Method and \
                m.virtual and \
                m.visibility != Scope.private
                
        # extract the virtual methods, avoiding duplications. The duplication
        # must take in account the full signature without the class name, so 
        # that inherited members are correctly excluded if the subclass overrides
        # them.
        def MethodSig(method):
            if method.const:
                const = ' const'
            else:
                const = ''
            if method.result:
                result = method.result.FullName()
            else:
                result = ''
            params = ', '.join([x.FullName() for x in method.parameters]) 
            return '%s %s(%s)%s%s' % (
                result, method.name, params, const, method.Exceptions())  

        already_added = {}
        self.virtual_methods = []
        for member in self.class_:
            if IsVirtual(member):
                already_added[MethodSig(member)] = None
                self.virtual_methods.append(member)

        for base in self.bases:
            base_methods = [copy.deepcopy(x) for x in base if IsVirtual(x)]
            for base_method in base_methods:
                self.class_.AddMember(base_method)
                
        all_methods = [x for x in self.class_ if IsVirtual(x)]
        
        for member in all_methods:
            sig = MethodSig(member)
            if IsVirtual(member) and not sig in already_added:
                self.virtual_methods.append(member)
                already_added[sig] = 0
            
    
    def Constructors(self):
        return self.class_.Constructors(publics_only=True)

    def GenerateDefinitions(self):
        defs = []
        for method in self.virtual_methods:
            exclude = self.info[method.name].exclude
            # generate definitions only for public methods and non-abstract methods
            if method.visibility == Scope.public and not exclude:
                defs.extend(self.MethodDefinition(method))
        return defs

    def GenerateVirtualWrapper(self, indent):
        'Return the wrapper for this class'

        def GenerateCallbackTypedef(method, indent):
            rename = self.info[method.name].rename or method.name
            result = method.result.FullName()

            params, param_names, param_types = _ParamsInfo(method)
            constantness = ''
            if method.const:
                constantness = ' const'

            param_types = ', '.join(param_types)

            # C# virtual function callback.
            callback_type = method.name + '_t'
            decl = indent + 'typedef %s (*%s)(%s)%s%s;\n' % (result, callback_type, param_types, constantness, method.Exceptions())
            return decl, (callback_type, method.name + '_callback')

        # generate the class code
        class_name = self.class_.FullName()
        code  = 'class %s: public %s\n' % (self.bridge_name, class_name)
        code += '{\n'
        code += 'public:\n'

        for method in self.virtual_methods:
            if not self.info[method.name].exclude:
                td_code, td_spec = GenerateCallbackTypedef(method, indent)
                code += td_code
                self.callback_typedefs.append(td_spec)

        if len(self.callback_typedefs) > 0:
            for cb_type in self.callback_typedefs:
                code += indent + '%s %s;\n' % cb_type
            code += '\n'

        # generate constructors (with the overloads for each one)
        for cons in self.Constructors(): # only public constructors
            minArgs = cons.minArgs
            maxArgs = cons.maxArgs
            # From the min number of arguments to the max number, generate
            # all versions of the given constructor.
            cons_code = ''
            for argNum in range(minArgs, maxArgs+1):
                params, param_names, param_types = _ParamsInfo(cons, argNum)
                cons_code += indent + '%s(%s)\n' % \
                    (self.bridge_name, params)
                cons_code += indent*2 + ': %s(%s) {;}\n\n' % \
                    (class_name, ', '.join(param_names))
            code += cons_code

        # Make sure we have a virtual destructor to go along with our virtual
        # methods.
        code += indent + 'virtual ~%s() {;}\n\n' % (self.bridge_name)

        # Generate the body.
        body = []
        for method in self.virtual_methods:
            if not self.info[method.name].exclude:
                body.append(self.Declaration(method, indent))
        body = '\n'.join(body)
        code += body + '\n'
        code += '};\n'
        return code
